import re # regular expressions used for parsing the tags file
import os # to get the current working directory
import os.path

__context_regular_expression = re.compile(r".*\t\/\^(.*)\$\/;\"\t.*")

class CantFindTagsFile(Exception):
    pass

class Ctags:
    def __init__(self, tags_file_path=None):
        if not tags_file_path:
            tags_file_path = find_tags_file()
        self.tags_file = tags_file_path
        self.tags_root = os.path.dirname(tags_file_path)
        self.py_tags = parse_tags_file(tags_file_path)

class CtagsFunctionSignatures:
    def __init__(self, tags_file_path=None):
        if not tags_file_path:
            tags_file_path = find_tags_file()
        self.tags_file = tags_file_path
        self.tags_root = os.path.dirname(tags_file_path)
        self.function_signatures = parse_function_signatures(tags_file_path)

def find_tags_file(dir=None, tags_file_name="tags"):
    "looks for a file in the current or given directory and all parent directories of that directory up until the root"
    file_in_dir = lambda d: d + os.path.sep + tags_file_name
    if not dir:
        dir = os.getcwd()
    while not os.path.isfile(file_in_dir(dir)):
        dir = os.path.normpath(dir)
        if dir == os.path.sep:
            raise CantFindTagsFile
        dir += os.path.sep + os.path.pardir

    return file_in_dir(os.path.normpath(dir))

def parse_tags_file(tags_file_path):
    "parses a tags file generated by ctags, returns a dict of identifiers with info about them"
    tags_file = open(tags_file_path)
    py_tags = {}
    for line in tags_file:
        if line[:6] == '!_TAG_': # tag program metadata
            continue
        cols = line.rstrip().split("\t")
        identifier = cols[0]
        file_path = cols[1]
        type = cols[-1] # type is the last field
        try:
            (context, ) = __context_regular_expression.match(line).groups()
        except ValueError:
            continue
        except AttributeError:
            continue

        if not py_tags.has_key(identifier):
            py_tags[identifier] = []
        py_tags[identifier].append({"file": file_path, "context": context, "type": type})

    return py_tags

__function_args_regular_expression = re.compile(r".*function\s+([^\);]*[\)]*)")
def parse_function_signatures(tags_file_path):
    tags_file = open(tags_file_path)
    functions_to_signatures = {}
    for line in tags_file:
        if line[:6] == '!_TAG_' or line.rstrip()[-1] != "f":
            continue
        try:
            context  = __context_regular_expression.match(line).groups()[0]
            signature = __function_args_regular_expression.match(context).groups()[0]
        except ValueError:
            continue
        except AttributeError:
            continue
        except IndexError:
            continue

        cols = line.rstrip().split("\t")
        identifier = cols[0]
        try:
            functions_to_signatures[identifier].append(signature)
        except KeyError:
            functions_to_signatures[identifier] = [signature]

    return functions_to_signatures
